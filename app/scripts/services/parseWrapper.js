// Generated by CoffeeScript 1.6.3
(function() {
  var __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  angular.module('artisanApp').factory('parseWrapper', [
    '$http', '$filter', '$cookieStore', '$q', '$log', function($http, $filter, $cookieStore, $q, $log) {
      var Collection, GeoPoint, Query, Resource, User, parseWrapper, pointerJson, pointerJsonForArray, pointerJsonForResource, _addSuccessAndErrorCallbacks, _http, _parseTransformResponse, _swapInstancesForPointers, _swapPointersForInstances;
      _parseTransformResponse = function(data, resourceClassName) {
        var classItem, item, newResults, resourceClass, _i, _len, _ref;
        data = angular.fromJson(data, true);
        if (data.results && data.results.length > 0) {
          resourceClass = Resource.resourceClassForName(resourceClassName);
          newResults = [];
          _ref = data.results;
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            item = _ref[_i];
            classItem = new resourceClass();
            classItem._copyData(item);
            newResults.push(classItem);
            _swapPointersForInstances(classItem);
          }
          data.results = newResults;
        }
        return data;
      };
      _swapPointersForInstances = function(item) {
        var newPointer, newResource, pointerClass, prop, propName, resourceClass, _results;
        _results = [];
        for (propName in item) {
          if (!__hasProp.call(item, propName)) continue;
          prop = item[propName];
          if (prop instanceof Object && prop.__type === "Pointer") {
            pointerClass = Resource.resourceClassForName(prop.className);
            if (!pointerClass) {
              console.error("Cannot find Resource Class for resource '" + prop.className + "'");
            }
            newPointer = new pointerClass(prop.objectId);
            item[propName] = newPointer;
          }
          if (prop instanceof Object && prop.__type === "Object") {
            resourceClass = Resource.resourceClassForName(prop.className);
            if (!resourceClass) {
              console.error("Cannot find Resource Class for resource '" + prop.className + "'");
            }
            newResource = new resourceClass(prop.objectId);
            newResource._copyData(prop);
            _results.push(item[propName] = newResource);
          } else {
            _results.push(void 0);
          }
        }
        return _results;
      };
      _swapInstancesForPointers = function(itemInstance) {
        var index, item, newInstance, prop, propName, _i, _len;
        for (propName in itemInstance) {
          if (!__hasProp.call(itemInstance, propName)) continue;
          prop = itemInstance[propName];
          if (prop instanceof Object) {
            newInstance = _swapInstancesForPointers(prop);
            if (newInstance) {
              itemInstance[propName] = newInstance;
            }
          }
          if (prop instanceof Array) {
            for (index = _i = 0, _len = itemInstance.length; _i < _len; index = ++_i) {
              item = itemInstance[index];
              newInstance = _swapInstancesForPointers(item);
              if (newInstance) {
                itemInstance[index] = newInstance;
              }
            }
          }
        }
        if (itemInstance instanceof Resource) {
          return itemInstance.asPointer();
        }
        return null;
      };
      _http = function(config) {
        var promise;
        promise = $http(config);
        _addSuccessAndErrorCallbacks(promise);
        return promise;
      };
      _addSuccessAndErrorCallbacks = function(promise) {
        var _this = this;
        promise.success = function(fn) {
          var newPromise;
          newPromise = promise.then(fn);
          _addSuccessAndErrorCallbacks(newPromise);
          return newPromise;
        };
        return promise.error = function(fn) {
          var newPromise;
          newPromise = promise.then(null, fn);
          _addSuccessAndErrorCallbacks(newPromise);
          return newPromise;
        };
      };
      GeoPoint = (function() {
        function GeoPoint(latitude, longitude) {
          this.latitude = latitude;
          this.longitude = longitude;
          this.__type = "GeoPoint";
        }

        return GeoPoint;

      })();
      Query = (function() {
        function Query(targetClass, whereClause) {
          this.targetClass = targetClass;
          _swapInstancesForPointers(whereClause);
          this.whereClause = whereClause;
          this.order = [];
          this.fieldsToInclude = [];
          this.limit = 200;
          this.skip = 0;
          this.isBusy = false;
          this.error = null;
          this.mightHaveMore = true;
          this.queryChangedWhileInProgress = false;
        }

        Query.prototype.ascending = function(orderKey) {
          this.order.push(orderKey);
          if (this.collectionPromise) {
            this.queryChangedWhileInProgress = true;
          }
          return this;
        };

        Query.prototype.descending = function(orderKey) {
          this.order.push("-" + orderKey);
          if (this.collectionPromise) {
            this.queryChangedWhileInProgress = true;
          }
          return this;
        };

        Query.prototype.include = function(fieldToInclude) {
          this.fieldsToInclude.push(fieldToInclude);
          if (this.collectionPromise) {
            this.queryChangedWhileInProgress = true;
          }
          return this;
        };

        Query.prototype.howMany = function(limit) {
          this.limit = limit;
          return this;
        };

        Query.prototype.fetch = function() {
          this.items = [];
          return this._fetchMore(this.limit, this.skip);
        };

        Query.prototype.more = function(howManyMore) {
          if (!howManyMore) {
            howManyMore = this.limit;
          }
          return this._fetchMore(howManyMore, this.items.length);
        };

        Query.prototype._fetchMore = function(limit, skip) {
          var collectionPromise, config, params,
            _this = this;
          this.error = null;
          params = {};
          if (this.collectionPromise) {
            if (this.queryChangedWhileInProgress) {
              throw "Calling fetch() on a query that was changed while it was in progress.  Not allowed!";
            }
            return this.collectionPromise;
          }
          if (this.whereClause != null) {
            params.where = JSON.stringify(this.whereClause);
          }
          params.limit = limit;
          params.skip = skip;
          if (this.order.length > 0) {
            params.order = this.order.join(",");
          }
          if (this.fieldsToInclude.length > 0) {
            params.include = this.fieldsToInclude.join(",");
          }
          config = {
            method: "GET",
            url: this._getURL(),
            params: params,
            transformResponse: function(data) {
              return _parseTransformResponse(data, _this.targetClass);
            }
          };
          $log.info(config.params);
          collectionPromise = _http(config);
          this.isBusy = true;
          this.collectionPromise = collectionPromise.then(function(response) {
            if (response.data.results.length < params.limit) {
              _this.mightHaveMore = false;
            }
            _this.isBusy = false;
            _this.items = _this.items.concat(response.data.results);
            _this.collectionPromise = null;
            _this.queryChangedWhileInProgress = false;
            return _this.items;
          }, function(errorResponse) {
            _this.isBusy = false;
            _this.error = {
              httpStatus: errorResponse.status,
              code: errorResponse.data.code,
              error: errorResponse.data.error
            };
            _this.collectionPromise = null;
            _this.queryChangedWhileInProgress = false;
            return _this.error;
          });
          _addSuccessAndErrorCallbacks(this.collectionPromise);
          return this.collectionPromise;
        };

        Query.prototype._getURL = function() {
          return "https://api.parse.com/1/classes/" + this.targetClass;
        };

        return Query;

      })();
      Resource = (function() {
        function Resource(objectId) {
          this.objectId = objectId || null;
          this.isBusy = false;
          this.isSaving = false;
          this.isLoading = false;
          this.isDeleting = false;
          this.error = null;
          this._initClassProperties();
        }

        Resource.query = function(whereClause) {
          return new Query(this.parseClassName, whereClause);
        };

        Resource.registerResource = function(resourceClass) {
          var existingResourceClass;
          existingResourceClass = this.registeredResources[resourceClass.parseClassName];
          if (existingResourceClass) {
            return existingResourceClass;
          }
          resourceClass.persistedProperties = resourceClass.register();
          return this.registeredResources[resourceClass.parseClassName] = resourceClass;
        };

        Resource.prototype.load = function() {
          return this.loadWithProperties();
        };

        Resource.prototype.loadWithProperties = function(arrayOfPointerPropsToLoad) {
          var collection, collectionName, collectionNames, collectionPromise, config, includes, loadPromise, pointerNames, promises, propsArray, _i, _len,
            _this = this;
          if (this.objectId === null || this.objectId === void 0) {
            throw "Cannot load resource!  obejctId is not set.";
          }
          pointerNames = [];
          collectionNames = [];
          if (arrayOfPointerPropsToLoad) {
            propsArray = arrayOfPointerPropsToLoad instanceof Array ? arrayOfPointerPropsToLoad : [arrayOfPointerPropsToLoad];
            collectionNames = this._cullCollectionNamesFromList(propsArray);
            pointerNames = _.difference(propsArray, collectionNames);
          }
          includes = pointerNames.join(",");
          config = {
            method: "GET",
            url: this._getURL(this)
          };
          if (includes && includes.length > 0) {
            config.params = {
              include: includes
            };
          }
          if (this.completeLoadPromise) {
            return this.completeLoadPromise;
          }
          this.isLoading = true;
          this.isBusy = true;
          loadPromise = _http(config).then(function(response) {
            _this._copyData(response.data);
            _swapPointersForInstances(_this);
            return _this;
          });
          promises = [loadPromise];
          for (_i = 0, _len = collectionNames.length; _i < _len; _i++) {
            collectionName = collectionNames[_i];
            collection = this[collectionName];
            collectionPromise = collection.query().fetch().success(function(query) {
              return _this[collectionName + "List"] = query.items;
            });
            promises.push(collectionPromise);
          }
          this.completeLoadPromise = $q.all(promises).then(function(promisesReponses) {
            _this.isLoading = _this.isBusy = false;
            _this.completeLoadPromise = null;
            return _this;
          }, function(errorResponse) {
            _this.isLoading = _this.isBusy = false;
            _this.completeLoadPromise = null;
            _this.error = {
              httpStatus: errorResponse.status,
              code: errorResponse.data.code,
              error: errorResponse.data.error
            };
            throw _this.error;
          });
          _addSuccessAndErrorCallbacks(this.completeLoadPromise);
          return this.completeLoadPromise;
        };

        Resource.prototype.save = function() {
          return this._save({});
        };

        Resource.prototype.isNew = function() {
          return this.objectId === null || this.objectId === void 0;
        };

        Resource.prototype.asPointer = function() {
          return pointerJsonForResource(this);
        };

        Resource.prototype._initClassProperties = function() {
          var prop, propValue, _results;
          _results = [];
          for (prop in this.constructor.persistedProperties) {
            propValue = this.constructor.persistedProperties[prop];
            if (propValue instanceof Collection) {
              this[prop] = new propValue.constructor(propValue.resourceName);
              this[prop].resource = this;
              _results.push(this[prop].collectionName = prop);
            } else {
              _results.push(this[prop] = propValue);
            }
          }
          return _results;
        };

        Resource.prototype._save = function(extraProperties) {
          var ajaxCall, config,
            _this = this;
          config = {
            method: "PUT",
            url: this._getURL(this)
          };
          if (this.isNew()) {
            config.method = "POST";
          }
          config.data = this._propertiesAsJson();
          angular.extend(config.data, extraProperties);
          if (this.isBusy) {
            window.console.log("Ajax call to " + config.method + ": " + config.url + " was aborted because another ajax call is already in progress");
            return;
          }
          this.isSaving = true;
          this.isBusy = true;
          return ajaxCall = _http(config).success(function(response) {
            var method, prop;
            _this._copyData(response.data);
            _this.isSaving = _this.isBusy = false;
            for (prop in _this) {
              if (!__hasProp.call(_this, prop)) continue;
              method = _this[prop] != null ? _this[prop]._clearOperations : null;
              if (typeof method === 'function') {
                _this[prop]._clearOperations();
              }
            }
            return _this;
          }).error(function(errorResponse) {
            _this.isSaving = _this.isBusy = false;
            throw errorResponse;
          });
        };

        Resource.prototype["delete"] = function() {
          var ajaxCall, config,
            _this = this;
          config = {
            method: "DELETE",
            url: this._getURL(this)
          };
          if (this.isBusy) {
            window.console.log("Ajax call to " + config.method + ": " + config.url + " was aborted because another ajax call is already in progress");
            return;
          }
          this.isDeleting = true;
          this.isBusy = true;
          return ajaxCall = _http(config).success(function(response) {
            var method, prop;
            _this.isDeleting = _this.isBusy = false;
            for (prop in _this) {
              if (!__hasProp.call(_this, prop)) continue;
              method = _this[prop] != null ? _this[prop]._clearOperations : null;
              if (typeof method === 'function') {
                _this[prop]._clearOperations();
              }
            }
            return _this;
          }).error(function(errorResponse) {
            _this.isDeleting = _this.isBusy = false;
            throw errorResponse;
          });
        };

        Resource.prototype._getURL = function() {
          if (this.isNew()) {
            return "https://api.parse.com/1/classes/" + this.constructor.parseClassName;
          }
          return "https://api.parse.com/1/classes/" + this.constructor.parseClassName + "/" + this.objectId;
        };

        Resource.prototype._propertiesAsJson = function() {
          var json, propName, propValue;
          json = {};
          if (!this.constructor.persistedProperties) {
            throw "registerResource() was not called on class " + this.constructor.parseClassName + "!";
          }
          for (propName in this) {
            if (!__hasProp.call(this, propName)) continue;
            if (this.constructor.persistedProperties.hasOwnProperty(propName)) {
              propValue = this[propName];
              if (propValue instanceof Collection) {
                if (propValue.resourcesToAdd.length > 0) {
                  json[propName] = {
                    __op: "AddRelation",
                    objects: pointerJsonForArray(propValue.resourcesToAdd)
                  };
                } else if (propValue.resourcesToRemove.length > 0) {
                  json[propName] = {
                    __op: "RemoveRelation",
                    objects: pointerJsonForArray(propValue.resourcesToRemove)
                  };
                }
              } else if (propValue instanceof Resource) {
                json[propName] = pointerJson(propValue);
              } else {
                json[propName] = propValue;
              }
            }
          }
          return json;
        };

        Resource.prototype._cullCollectionNamesFromList = function(propsArray) {
          var collectionNames, propName, _i, _len;
          collectionNames = [];
          for (_i = 0, _len = propsArray.length; _i < _len; _i++) {
            propName = propsArray[_i];
            if (this[propName] && this[propName] instanceof Collection) {
              collectionNames.push(propName);
            }
          }
          return collectionNames;
        };

        Resource.prototype._copyData = function(dataToCopy) {
          var prop, propValue, _results;
          _results = [];
          for (prop in dataToCopy) {
            if (!__hasProp.call(dataToCopy, prop)) continue;
            propValue = dataToCopy[prop];
            if (!(propValue instanceof Object && propValue.__type === "Relation")) {
              _results.push(this[prop] = propValue);
            } else {
              _results.push(void 0);
            }
          }
          return _results;
        };

        Resource.registeredResources = {};

        Resource.resourceClassForName = function(resourceName) {
          return this.registeredResources[resourceName];
        };

        return Resource;

      })();
      Collection = (function() {
        function Collection(resourceName) {
          this.resourceName = resourceName;
          this.resourcesToAdd = [];
          this.resourcesToRemove = [];
          this.operations = [];
        }

        Collection.prototype.add = function(resourceOrResourceArray) {
          var resource, resourceArray, _i, _len, _results;
          if (!(resourceOrResourceArray instanceof Resource) && !(resourceOrResourceArray instanceof Array)) {
            throw "Param passed to add is not a Resource object as it should be";
          }
          if (this.resourcesToRemove.length > 0) {
            throw "Cannot add to a collection that already has items to remove.  Save first, then remove";
          }
          resourceArray = resourceOrResourceArray instanceof Array ? resourceOrResourceArray : [resourceOrResourceArray];
          _results = [];
          for (_i = 0, _len = resourceArray.length; _i < _len; _i++) {
            resource = resourceArray[_i];
            _results.push(this.resourcesToAdd.push(resource));
          }
          return _results;
        };

        Collection.prototype.remove = function(resourceOrResourceArray) {
          var resource, resourceArray, _i, _len, _results;
          if (!(resourceOrResourceArray instanceof Resource) && !(resourceOrResourceArray instanceof Array)) {
            throw "Param passed to remove is not a Resource object as it should be";
          }
          if (this.resourcesToAdd.length > 0) {
            throw "Cannot remove from a collection that already has items to add.  Save first, then add";
          }
          resourceArray = resourceOrResourceArray instanceof Array ? resourceOrResourceArray : [resourceOrResourceArray];
          _results = [];
          for (_i = 0, _len = resourceArray.length; _i < _len; _i++) {
            resource = resourceArray[_i];
            _results.push(this.resourcesToRemove.push(resource));
          }
          return _results;
        };

        Collection.prototype.query = function(whereClause) {
          var ourWhereClause;
          ourWhereClause = angular.copy(whereClause || {});
          ourWhereClause.$relatedTo = {
            object: pointerJson(this.resource),
            key: this.collectionName
          };
          if (!this.collectionName) {
            throw "collectionName is not set for collection of " + this.resourceName;
          }
          return new Query(this.resourceName, ourWhereClause);
        };

        Collection.prototype._clearOperations = function() {
          this.resourcesToAdd = [];
          return this.resourcesToRemove = [];
        };

        return Collection;

      })();
      User = (function(_super) {
        var currentUser;

        __extends(User, _super);

        function User(userId) {
          this.isAuthenticating = false;
          this.email = void 0;
          this.username = void 0;
          User.__super__.constructor.call(this, userId);
        }

        currentUser = null;

        User.parseClassName = "_User";

        User.register = function() {
          return {
            email: void 0,
            username: void 0
          };
        };

        User.login = function(username, password) {
          var user;
          user = new User;
          user.username = username;
          return user.login(password);
        };

        User.loggedIn = function() {
          return User.current() != null;
        };

        User.current = function() {
          if (currentUser != null) {
            return currentUser;
          }
          if ($cookieStore.get("user_id") && $cookieStore.get("sessionToken")) {
            currentUser = new User($cookieStore.get("user_id"));
            $http.defaults.headers.common['X-Parse-Session-Token'] = $cookieStore.get("sessionToken");
            currentUser.load();
          }
          return currentUser;
        };

        User.requestPasswordReset = function(emailAddress) {
          var ajaxCall, config,
            _this = this;
          config = {
            method: "POST",
            url: "https://api.parse.com/1/requestPasswordReset",
            data: {
              email: emailAddress
            }
          };
          this.isBusy = true;
          return ajaxCall = _http(config).success(function(response) {
            _this.isBusy = false;
            return response;
          }).error(function(errorResponse) {
            _this.isBusy = false;
            throw errorResponse;
          });
        };

        User.prototype.signUp = function(password) {
          var _this = this;
          this.isAuthenticating = true;
          return this._save({
            password: password
          }).success(function(data, status, headers, config) {
            _this.isAuthenticating = false;
            return _this.login(password);
          }).error(function(errorResponse) {
            _this.isAuthenticating = false;
            throw errorResponse;
          });
        };

        User.prototype.login = function(password) {
          var ajaxCall, config,
            _this = this;
          config = {
            method: "GET",
            url: "https://api.parse.com/1/login",
            params: {
              username: this.username,
              password: password
            }
          };
          this.isAuthenticating = this.isBusy = true;
          ajaxCall = _http(config).success(function(response) {
            _this._copyData(response.data);
            _swapPointersForInstances(_this);
            _this.isAuthenticating = _this.isBusy = false;
            $http.defaults.headers.common['X-Parse-Session-Token'] = response.data.sessionToken;
            $cookieStore.put("username", _this.username);
            $cookieStore.put("user_id", _this.objectId);
            $cookieStore.put("sessionToken", response.data.sessionToken);
            currentUser = _this;
            return _this;
          }).error(function(errorResponse) {
            _this.isAuthenticating = _this.isBusy = false;
            throw errorResponse;
          });
          return ajaxCall;
        };

        User.prototype.logOut = function() {
          currentUser = null;
          delete $http.defaults.headers.common['X-Parse-Session-Token'];
          $cookieStore.remove("username");
          $cookieStore.remove("user_id");
          return $cookieStore.remove("sessionToken");
        };

        User.prototype.isCurrent = function() {
          var _ref;
          return this.objectId && ((_ref = User.current) != null ? _ref.objectId : void 0) === this.objectId;
        };

        User.prototype._getURL = function() {
          if (this.isNew()) {
            return "https://api.parse.com/1/users";
          }
          return "https://api.parse.com/1/users/" + this.objectId;
        };

        return User;

      })(Resource);
      parseWrapper = {
        Resource: Resource,
        Collection: Collection,
        Query: Query,
        User: User,
        GeoPoint: GeoPoint,
        registerFunction: function(functionName) {
          return function(params) {
            var config;
            config = {
              method: "POST",
              url: "https://api.parse.com/1/functions/" + functionName
            };
            config.data = {};
            angular.extend(config.data, params);
            return _http(config);
          };
        }
      };
      pointerJson = function(resourceOrResourceArray) {
        if (resourceOrResourceArray instanceof Array) {
          return pointerJsonForArray(resourceOrResourceArray);
        } else {
          return pointerJsonForResource(resourceOrResourceArray);
        }
      };
      pointerJsonForResource = function(resource) {
        var obj;
        if (resource.objectId === null) {
          throw "Cannot convert object to Pointer.  Object has not been saved!";
        }
        return obj = {
          __type: "Pointer",
          className: resource.constructor.parseClassName,
          objectId: resource.objectId
        };
      };
      pointerJsonForArray = function(resourceArray) {
        var resource, _i, _len, _results;
        _results = [];
        for (_i = 0, _len = resourceArray.length; _i < _len; _i++) {
          resource = resourceArray[_i];
          _results.push(pointerJsonForResource(resource));
        }
        return _results;
      };
      return parseWrapper;
    }
  ]);

}).call(this);

/*
//@ sourceMappingURL=parseWrapper.map
*/
